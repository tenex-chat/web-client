This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/components/chat/components/ConversationAgents.tsx, src/hooks/useProjectOnlineAgents.ts, src/lib/ndk-events/NDKProjectStatus.ts, src/components/common/ProfileDisplay.tsx, src/components/chat/ChatHeader.tsx
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  components/
    chat/
      components/
        ConversationAgents.tsx
    common/
      ProfileDisplay.tsx
  hooks/
    useProjectOnlineAgents.ts
  lib/
    ndk-events/
      NDKProjectStatus.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/chat/components/ConversationAgents.tsx">
import { useMemo, useState } from 'react'
import { NDKEvent } from '@nostr-dev-kit/ndk-hooks'
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { ProfileDisplay } from '@/components/common/ProfileDisplay'
import { useProjectOnlineAgents } from '@/hooks/useProjectOnlineAgents'
import { useProjectOnlineModels } from '@/hooks/useProjectOnlineModels'
import { useNDK, useNDKCurrentUser } from '@nostr-dev-kit/ndk-hooks'
import { toast } from 'sonner'
import type { Message } from '../hooks/useChatMessages'
import type { NDKProject } from '@/lib/ndk-events/NDKProject'
interface ConversationAgentsProps {
  messages: Message[]
  project: NDKProject
  rootEvent: NDKEvent | null
}
interface AgentInfo {
  pubkey: string
  name: string
  currentModel?: string
  lastMessageId?: string
}
export function ConversationAgents({ messages, project, rootEvent }: ConversationAgentsProps) {
  const { ndk } = useNDK()
  const user = useNDKCurrentUser()
  const onlineAgents = useProjectOnlineAgents(project.dTag)
  const availableModels = useProjectOnlineModels(project.dTag)
  const [sendingModelChange, setSendingModelChange] = useState<string | null>(null)
  // Extract unique agents from the conversation
  const conversationAgents = useMemo(() => {
    const agentsMap = new Map<string, AgentInfo>()
    // Go through messages to find unique agents
    messages.forEach(message => {
      const pubkey = message.event.pubkey
      // Skip user messages
      if (pubkey === user?.pubkey) return
      // Find agent info from online agents
      const agentInfo = onlineAgents.find(a => a.pubkey === pubkey)
      if (agentInfo) {
        if (!agentsMap.has(pubkey)) {
          agentsMap.set(pubkey, {
            pubkey,
            name: agentInfo.name,
            lastMessageId: message.id
          })
        } else {
          // Update last message ID
          const existing = agentsMap.get(pubkey)!
          existing.lastMessageId = message.id
        }
      }
    })
    return Array.from(agentsMap.values())
  }, [messages, onlineAgents, user?.pubkey])
  const handleModelChange = async (agentPubkey: string, newModel: string) => {
    if (!ndk || !user || !rootEvent) return
    setSendingModelChange(agentPubkey)
    try {
      // Create a model change event (kind 24020)
      const modelChangeEvent = new NDKEvent(ndk)
      modelChangeEvent.kind = 24020
      modelChangeEvent.content = ''
      modelChangeEvent.tags = [
        ['p', agentPubkey], // Target agent
        ['model', newModel], // New model
        ['a', project.tagId()], // Project reference
        ['e', rootEvent.id, '', '', user.pubkey], // Root event reference with user pubkey
        ['p', user.pubkey] // User pubkey
      ]
      await modelChangeEvent.publish()
      toast.success(`Model changed to ${newModel}`)
    } catch (error) {
      console.error('Failed to change model:', error)
      toast.error('Failed to change model')
    } finally {
      setSendingModelChange(null)
    }
  }
  if (conversationAgents.length === 0) return null
  return (
    <div className="flex items-center gap-1">
      {conversationAgents.map(agent => (
        <Popover key={agent.pubkey}>
          <PopoverTrigger asChild>
            <button className="relative group hover:opacity-80 transition-opacity">
              <ProfileDisplay
                pubkey={agent.pubkey}
                size="sm"
                showName={false}
                showAvatar={true}
                avatarClassName="ring-2 ring-transparent hover:ring-primary transition-all cursor-pointer"
              />
            </button>
          </PopoverTrigger>
          <PopoverContent className="w-80">
            <div className="space-y-3">
              <div className="flex items-center gap-3">
                <ProfileDisplay
                  pubkey={agent.pubkey}
                  size="md"
                  showName={false}
                  showAvatar={true}
                />
                <div>
                    <h4 className="text-sm font-semibold">{project.title} / {agent.name}</h4>
                    <p className="text-xs text-muted-foreground truncate max-w-[200px]">
                      {agent.pubkey}
                    </p>
                  </div>
                </div>
                <div className="space-y-2">
                  <label className="text-xs font-medium text-muted-foreground">
                    Model
                  </label>
                  {availableModels.length === 0 ? (
                    <p className="text-xs text-muted-foreground">No models available</p>
                  ) : (
                    <Select
                      value={agent.currentModel}
                      onValueChange={(value) => handleModelChange(agent.pubkey, value)}
                      disabled={sendingModelChange === agent.pubkey}
                    >
                      <SelectTrigger className="w-full h-8 text-xs">
                        <SelectValue placeholder="Select model" />
                      </SelectTrigger>
                      <SelectContent>
                        {availableModels.map(model => (
                          <SelectItem 
                            key={`${model.provider}-${model.model}`} 
                            value={model.model}
                            className="text-xs"
                          >
                            {model.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  )}
                </div>
              </div>
            </PopoverContent>
          </Popover>
        ))}
    </div>
  )
}
</file>

<file path="src/components/common/ProfileDisplay.tsx">
import { useProfile } from "@nostr-dev-kit/ndk-hooks";
import { Avatar, AvatarFallback, AvatarImage } from "../ui/avatar";
import { cn } from "@/lib/utils";
interface ProfileDisplayProps {
    pubkey: string;
    size?: "sm" | "md" | "lg";
    showName?: boolean;
    showAvatar?: boolean;
    className?: string;
    nameClassName?: string;
    avatarClassName?: string;
}
export function ProfileDisplay({
    pubkey,
    size = "sm",
    showName = true,
    showAvatar = true,
    className = "",
    nameClassName = "",
    avatarClassName = "",
}: ProfileDisplayProps) {
    const userProfile = useProfile(pubkey);
    const sizeClasses = {
        sm: { avatar: "w-6 h-6", text: "text-sm" },
        md: { avatar: "w-8 h-8", text: "text-base" },
        lg: { avatar: "w-10 h-10", text: "text-lg" },
    };
    const displayName = userProfile?.displayName || userProfile?.name || pubkey.slice(0, 8);
    const avatarUrl = userProfile?.image || userProfile?.picture;
    const getInitials = (name: string) => {
        const words = name.split(' ');
        if (words.length >= 2) {
            return words[0][0] + words[1][0];
        }
        return name.slice(0, 2).toUpperCase();
    };
    return (
        <div className={cn("flex items-center gap-2", className)}>
            {showAvatar && (
                <Avatar className={cn(sizeClasses[size].avatar, avatarClassName)}>
                    <AvatarImage src={avatarUrl} alt={displayName} />
                    <AvatarFallback className="text-xs">
                        {getInitials(displayName)}
                    </AvatarFallback>
                </Avatar>
            )}
            {showName && (
                <span className={cn(sizeClasses[size].text, "truncate", nameClassName)}>
                    {displayName}
                </span>
            )}
        </div>
    );
}
</file>

<file path="src/hooks/useProjectOnlineAgents.ts">
import { useMemo } from 'react'
import { useProjectStatus } from '@/stores/projects'
export interface ProjectOnlineAgent {
  pubkey: string
  name: string
  status?: string
  lastSeen?: number
}
/**
 * Fetches the ONLINE agents for a project from the project status.
 * These are agents that are currently online and available to work with the project.
 * 
 * For CONFIGURED agents (project settings), use useProjectConfiguredAgents() instead!
 * 
 * This should be used in chat interfaces, agent selectors, and anywhere you need
 * to interact with agents that are actually available.
 */
export function useProjectOnlineAgents(projectDTag?: string): ProjectOnlineAgent[] {
  const projectStatus = useProjectStatus(projectDTag)
  const onlineAgents = useMemo(() => {
    if (!projectStatus?.agents) return []
    return projectStatus.agents.map(agent => ({
      pubkey: agent.pubkey,
      name: agent.name || agent.pubkey.slice(0, 8),
      status: agent.status,
      lastSeen: agent.lastSeen
    }))
  }, [projectStatus])
  return onlineAgents
}
</file>

<file path="src/lib/ndk-events/NDKProjectStatus.ts">
import { NDKEvent, type NDKKind, type NostrEvent } from '@nostr-dev-kit/ndk-hooks'
import type NDK from '@nostr-dev-kit/ndk-hooks'
import { EVENT_KINDS } from '../constants'
export interface ProjectAgent {
  pubkey: string
  name: string
  role?: string
  status?: string
  lastSeen?: number
}
export interface ProjectModel {
  provider: string  // e.g., "anthropic/claude-sonnet-4"
  name: string      // e.g., "sonnet"
}
export interface ExecutionQueueItem {
  conversationId: string
  startTime?: number
  position?: number
}
export interface ExecutionQueue {
  active: ExecutionQueueItem | null
  waiting: ExecutionQueueItem[]
  totalWaiting: number
}
export class NDKProjectStatus extends NDKEvent {
  static kind: NDKKind = EVENT_KINDS.PROJECT_STATUS as NDKKind
  constructor(ndk?: NDK, rawEvent?: NostrEvent | NDKEvent) {
    super(ndk, rawEvent)
    this.kind = NDKProjectStatus.kind
    if (!this.tags) {
      this.tags = []
    }
    if (!this.content) {
      this.content = ''
    }
  }
  get projectId(): string | undefined {
    // Look for 'a' tag (NIP-33 reference)
    const aTag = this.tagValue('a')
    if (aTag) return aTag
    // Fallback to 'e' tag
    return this.tagValue('e')
  }
  set projectId(value: string | undefined) {
    this.removeTag('a')
    this.removeTag('e')
    if (value) {
      // If it's a NIP-33 reference (contains colons), use 'a' tag
      if (value.includes(':')) {
        this.tags.push(['a', value])
      } else {
        // Otherwise use 'e' tag for event ID
        this.tags.push(['e', value])
      }
    }
  }
  // The project is online if this event exists and is recent
  get isOnline(): boolean {
    if (!this.created_at) return false
    const fiveMinutesAgo = Math.floor(Date.now() / 1000) - 300
    return this.created_at > fiveMinutesAgo
  }
  get lastSeen(): Date | undefined {
    return this.created_at ? new Date(this.created_at * 1000) : undefined
  }
  get agents(): ProjectAgent[] {
    const agents: ProjectAgent[] = []
    for (const tag of this.tags) {
      if (tag[0] === 'agent' && tag[1]) {
        agents.push({
          pubkey: tag[1],
          name: tag[2] || 'Unknown',
          role: tag[3]
        })
      }
    }
    return agents
  }
  set agents(agentList: ProjectAgent[]) {
    // Remove existing agent tags
    this.tags = this.tags.filter(tag => tag[0] !== 'agent')
    // Add new agent tags
    for (const agent of agentList) {
      const tag = ['agent', agent.pubkey, agent.name]
      if (agent.role) tag.push(agent.role)
      this.tags.push(tag)
    }
  }
  get models(): ProjectModel[] {
    const models: ProjectModel[] = []
    for (const tag of this.tags) {
      if (tag[0] === 'model' && tag[1] && tag[2]) {
        models.push({
          provider: tag[1],
          name: tag[2]
        })
      }
    }
    return models
  }
  set models(modelList: ProjectModel[]) {
    // Remove existing model tags
    this.tags = this.tags.filter(tag => tag[0] !== 'model')
    // Add new model tags
    for (const model of modelList) {
      this.tags.push(['model', model.provider, model.name])
    }
  }
  get executionQueue(): ExecutionQueue {
    const queue: ExecutionQueue = {
      active: null,
      waiting: [],
      totalWaiting: 0
    }
    const queueTags = this.tags.filter(tag => tag[0] === 'execution-queue')
    let waitingPosition = 1
    for (const tag of queueTags) {
      if (tag[1]) {
        const conversationId = tag[1]
        const status = tag[2]
        if (status === 'active') {
          // Active conversation with optional start time
          queue.active = {
            conversationId,
            startTime: tag[3] ? parseInt(tag[3]) : undefined
          }
        } else {
          // Waiting conversation
          queue.waiting.push({
            conversationId,
            position: waitingPosition++
          })
        }
      }
    }
    queue.totalWaiting = queue.waiting.length
    return queue
  }
  set executionQueue(queue: ExecutionQueue) {
    // Remove existing execution-queue tags
    this.tags = this.tags.filter(tag => tag[0] !== 'execution-queue')
    // Add active conversation if exists
    if (queue.active) {
      const tag: string[] = ['execution-queue', queue.active.conversationId, 'active']
      if (queue.active.startTime) {
        tag.push(queue.active.startTime.toString())
      }
      this.tags.push(tag)
    }
    // Add waiting conversations
    for (const item of queue.waiting) {
      this.tags.push(['execution-queue', item.conversationId])
    }
  }
  static from(ndk: NDK, projectId: string, agents: ProjectAgent[], models: ProjectModel[]): NDKProjectStatus {
    const event = new NDKProjectStatus(ndk)
    event.projectId = projectId
    event.agents = agents
    event.models = models
    return event
  }
}
</file>

</files>
